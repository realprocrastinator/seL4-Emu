<html>
<head><title>2021 Thesis B Presentation (27)</title>
<link href='slides.css' rel='stylesheet' type='text/css'>
<script language="JavaScript">
// <!--
function getKey(keyStroke) {
	isNetscape = (navigator.appName.indexOf('Netscape') == 0)
	eventChooser = (isNetscape) ? keyStroke.which : event.keyCode;
	which = String.fromCharCode(eventChooser);
	if (which == ' ') window.location = "slide028.html";
	if (which == 'n') window.location = "slide028.html";
	if (which == 'h') window.location = "slide000.html";
	if (which == 'b') window.location = "slide026.html";
}
document.onkeypress = getKey;
// -->
</script>

</head>
<body>
<a href="slide026.html"><img border=0 alt="[prev]" src="icon/prev.gif"></a>
<a href="slide001.html"><span style="font-size:14pt;">27</span></a>
<a href="slide028.html"><img border=0 alt="[next]" src="icon/next.gif"></a>

<div align='center'><table height='95%' width='92%'><tr><td valign='top'>
<div align='center'><h3>Future Work</h3></div>

Most of the rudimentary designing and developing work of this project has been done. However, due to the time limits <small>(I've been blocked on some problems and bugs for quite a long time)</small> and my capability. There are still lots of work that haven't been done yet.

<h4>Still working on it, might be finished soon</h4>
<ul>
<li> The current platform info collection in the kernel booting stage is hardcoded as it's not quite important, but we can make it be configured by the user.
<li> The current implementation only supports running the roottask at the moment, should be extended to run multiple seL4 applications.
<li> The current implementation has only been tested on simple applications, should be tested on more complicated applications. <samll>(e.g. capdl-loader, seL4 test suites)</samll>
<li> About emulating scheduling, I've just come out with the idea recently, still implementing it.<br>
	To emulate the round robin scheduling in master kernel, we can use blocking sockets, so each time kernel uses the scheduling algorithm to determine the next running seL4 thread and only replies to it. Hence all other seL4 applications will block on the socket except one that has been chosen.<br> 
	To emulate the preemption, we can set a timer in the kernel emulator, and signal our seL4 application, then the signal handler routine is invoked and block on the socket until the next IPC message is passed from the kernel emulator telling it to resume. 
</ul>

</td></tr></table></div>
</body>
</html>
